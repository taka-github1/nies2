import{g as z,E as Y,s as p,x as b,gu as B}from"./index-6a6230c9.js";import{A as k,f as E,P as s,B as x,G as u,M as f,U,L as R,D as w,V as C}from"./enums-b14466b3.js";const K=z.getLogger("esri.views.webgl.checkWebGLError");function q(e,t){switch(t){case e.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case e.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case e.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case e.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case e.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case e.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const W=!!Y("enable-feature:webgl-debug");function j(){return W}function ne(){return W}function D(e){if(j()){const t=e.getError();if(t){const r=q(e,t),i=new Error().stack;K.error(new p("webgl-error","WebGL error occurred",{message:r,stack:i}))}}}var L;(function(e){e[e.Texture=0]="Texture",e[e.RenderBuffer=1]="RenderBuffer"})(L||(L={}));function ce(e){const t=e.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function le(e,t,r,i,o=0){var d,_,n;const c=e.gl;e.bindBuffer(r);for(const a of i){const l=t.get(a.name);l===void 0&&console.error(`There is no location for vertex attribute '${a.name}' defined.`);const m=o*a.stride;if(a.count<=4)c.vertexAttribPointer(l,a.count,a.type,a.normalized,a.stride,a.offset+m),c.enableVertexAttribArray(l),a.divisor>0&&((d=e.gl2)==null||d.vertexAttribDivisor(l,a.divisor));else if(a.count===9)for(let h=0;h<3;h++)c.vertexAttribPointer(l+h,3,a.type,a.normalized,a.stride,a.offset+12*h+m),c.enableVertexAttribArray(l+h),a.divisor>0&&((_=e.gl2)==null||_.vertexAttribDivisor(l+h,a.divisor));else if(a.count===16)for(let h=0;h<4;h++)c.vertexAttribPointer(l+h,4,a.type,a.normalized,a.stride,a.offset+16*h+m),c.enableVertexAttribArray(l+h),a.divisor>0&&((n=e.gl2)==null||n.vertexAttribDivisor(l+h,a.divisor));else console.error("Unsupported vertex attribute element count: "+a.count)}}function _e(e,t,r,i){var c,d,_;const o=e.gl;e.bindBuffer(r);for(const n of i){const a=t.get(n.name);if(n.count<=4)o.disableVertexAttribArray(a),n.divisor&&n.divisor>0&&((c=e.gl2)==null||c.vertexAttribDivisor(a,0));else if(n.count===9)for(let l=0;l<3;l++)o.disableVertexAttribArray(a+l),n.divisor&&n.divisor>0&&((d=e.gl2)==null||d.vertexAttribDivisor(a+l,0));else if(n.count===16)for(let l=0;l<4;l++)o.disableVertexAttribArray(a+l),n.divisor&&n.divisor>0&&((_=e.gl2)==null||_.vertexAttribDivisor(a+l,0));else console.error("Unsupported vertex attribute element count: "+n.count)}e.unbindBuffer(k.ARRAY_BUFFER)}function Z(e){switch(e){case u.ALPHA:case u.LUMINANCE:case u.RED:case u.RED_INTEGER:case s.R8:case s.R8I:case s.R8UI:case s.R8_SNORM:case x.STENCIL_INDEX8:return 1;case u.LUMINANCE_ALPHA:case u.RG:case u.RG_INTEGER:case s.RGBA4:case s.R16F:case s.R16I:case s.R16UI:case s.RG8:case s.RG8I:case s.RG8UI:case s.RG8_SNORM:case s.RGB565:case s.RGB5_A1:case x.DEPTH_COMPONENT16:return 2;case u.DEPTH_COMPONENT:case u.RGB:case u.RGB_INTEGER:case s.RGB8:case s.RGB8I:case s.RGB8UI:case s.RGB8_SNORM:case s.SRGB8:case x.DEPTH_COMPONENT24:return 3;case u.DEPTH_STENCIL:case u.DEPTH24_STENCIL8:case u.RGBA:case u.RGBA_INTEGER:case s.RGBA8:case s.R32F:case s.R11F_G11F_B10F:case s.RG16F:case s.R32I:case s.R32UI:case s.RG16I:case s.RG16UI:case s.RGBA8I:case s.RGBA8UI:case s.RGBA8_SNORM:case s.SRGB8_ALPHA8:case s.RGB9_E5:case s.RGB10_A2UI:case s.RGB10_A2:case x.DEPTH_STENCIL:case x.DEPTH_COMPONENT32F:case x.DEPTH24_STENCIL8:return 4;case x.DEPTH32F_STENCIL8:return 5;case s.RGB16F:case s.RGB16I:case s.RGB16UI:return 6;case s.RG32F:case s.RG32I:case s.RG32UI:case s.RGBA16F:case s.RGBA16I:case s.RGBA16UI:return 8;case s.RGB32F:case s.RGB32I:case s.RGB32UI:return 12;case s.RGBA32F:case s.RGBA32I:case s.RGBA32UI:return 16;case E.COMPRESSED_RGB_S3TC_DXT1_EXT:case E.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case E.COMPRESSED_RGBA_S3TC_DXT3_EXT:case E.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case E.COMPRESSED_R11_EAC:case E.COMPRESSED_SIGNED_R11_EAC:case E.COMPRESSED_RGB8_ETC2:case E.COMPRESSED_SRGB8_ETC2:case E.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case E.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case E.COMPRESSED_RG11_EAC:case E.COMPRESSED_SIGNED_RG11_EAC:case E.COMPRESSED_RGBA8_ETC2_EAC:case E.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}class J{constructor(t=0,r=t){this.width=t,this.height=r,this.target=f.TEXTURE_2D,this.pixelFormat=u.RGBA,this.dataType=U.UNSIGNED_BYTE,this.samplingMode=R.LINEAR,this.wrapMode=w.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}function Q(e){return e.width<=0||e.height<=0?0:e.width*e.height*(e.hasMipmap?4/3:1)*(e.internalFormat==null?4:Z(e.internalFormat))}class O extends J{constructor(t,r){switch(super(),this.context=t,Object.assign(this,r),this.internalFormat){case s.R16F:case s.R16I:case s.R16UI:case s.R32F:case s.R32I:case s.R32UI:case s.R8_SNORM:case s.R8:case s.R8I:case s.R8UI:this.pixelFormat=u.RED}}static validate(t,r){return new O(t,r)}}const F=4;let A=class{constructor(e,t=null,r=null){if(this.type=L.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=t;else{const i=O.validate(e,t);if(!i)throw new p("Texture descriptor invalid");this._descriptor=i}if(this._descriptor.context.instanceCounter.increment(C.Texture,this),this._descriptor.context.type!==b.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),I(this._descriptor.target)))throw new p("3D and array textures are not supported in WebGL1");this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get gpuMemoryUsage(){return se.delete(this),Q(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._descriptor.context.instanceCounter.decrement(C.Texture,this),this._glName=null)}release(){this.dispose()}resize(e,t){const r=this._descriptor;if(r.width!==e||r.height!==t){if(this._wasImmutablyAllocated)throw new p("Immutable textures can't be resized!");r.width=e,r.height=t,this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let t=f.TEXTURE_CUBE_MAP_POSITIVE_X;t<=f.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}setData(e){this._setData(e)}_setData(e,t){if(!this._descriptor.context||!this._descriptor.context.gl)return;const r=this._descriptor.context.gl;D(r),this._glName||(this._glName=r.createTexture()),e===void 0&&(e=null);const i=this._descriptor,o=t??i.target,c=I(o);e===null&&(i.width=i.width||F,i.height=i.height||F,c&&(i.depth=i.depth??1));const d=this._descriptor.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),P(this._descriptor.context,i),this._configurePixelStorage(),D(r);const _=this._deriveInternalFormat();if(G(e)){let n="width"in e?e.width:e.codedWidth,a="height"in e?e.height:e.codedHeight;const l=1;e instanceof HTMLVideoElement&&(n=e.videoWidth,a=e.videoHeight),i.width&&i.height,c&&i.depth,i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,_,i.hasMipmap,n,a,l),this._texImage(o,0,_,n,a,l,e),D(r),i.hasMipmap&&this.generateMipmap(),i.width||(i.width=n),i.height||(i.height=a),c&&!i.depth&&(i.depth=l)}else{const{width:n,height:a,depth:l}=i;if(n==null||a==null)throw new p("Width and height must be specified!");if(c&&l==null)throw new p("Depth must be specified!");if(i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,_,i.hasMipmap,n,a,l),N(e)){const m=e.levels,h=X(o,n,a,l),g=Math.min(h-1,m.length-1);this._descriptor.context.gl2!=null?r.texParameteri(i.target,this._descriptor.context.gl2.TEXTURE_MAX_LEVEL,g):i.hasMipmap=i.hasMipmap&&h===m.length;const T=_;if(!re(T))throw new p("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((M,S,H,V)=>{const $=m[Math.min(M,m.length-1)];this._compressedTexImage(o,M,T,S,H,V,$)},g)}else this._texImage(o,0,_,n,a,l,e),D(r),i.hasMipmap&&this.generateMipmap()}v(r,this._descriptor),y(r,this._descriptor),ee(this._descriptor.context,this._descriptor),D(r),this._descriptor.context.bindTexture(d,A.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,t,r,i,o,c,d=0){c||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const _=this._descriptor.context.gl,n=this._descriptor.context.gl2,a=this._descriptor,l=this._deriveInternalFormat(),{pixelFormat:m,dataType:h,target:g,isImmutable:T}=a;if(T&&!this._wasImmutablyAllocated)throw new p("Cannot update immutable texture before allocation!");const M=this._descriptor.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES,!0);if((t<0||r<0||i>a.width||o>a.height||t+i>a.width||r+o>a.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),d){if(!n)return void console.error("Webgl2 must be enabled to use dataRowOffset!");_.pixelStorei(n.UNPACK_SKIP_ROWS,d)}if(G(c)?n?n.texSubImage2D(g,e,t,r,i,o,m,h,c):_.texSubImage2D(g,e,t,r,m,h,c):N(c)?_.compressedTexSubImage2D(g,e,t,r,i,o,l,c.levels[e]):_.texSubImage2D(g,e,t,r,i,o,m,h,c),d){if(!n)return void console.error("Webgl2 must be enabled to use dataRowOffset!");_.pixelStorei(n.UNPACK_SKIP_ROWS,0)}this._descriptor.context.bindTexture(M,A.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,t,r,i,o,c,d,_){_||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const n=this._descriptor.context.gl2;if(n==null)throw new p("3D textures are not supported in WebGL1");const a=this._descriptor,l=this._deriveInternalFormat(),{pixelFormat:m,dataType:h,isImmutable:g,target:T}=a;if(g&&!this._wasImmutablyAllocated)throw new p("Cannot update immutable texture before allocation!");I(T)||console.warn("Attempting to set 3D texture data on a non-3D texture");const M=this._descriptor.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);if(this._descriptor.context.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),(t<0||r<0||i<0||o>a.width||c>a.height||d>a.depth||t+o>a.width||r+c>a.height||i+d>a.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),N(_))_=_.levels[e],n.compressedTexSubImage3D(T,e,t,r,i,o,c,d,l,_);else{const S=_;n.texSubImage3D(T,e,t,r,i,o,c,d,m,h,S)}this._descriptor.context.bindTexture(M,A.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new p("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,P(this._descriptor.context,e)}e.samplingMode===R.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=R.LINEAR_MIPMAP_NEAREST):e.samplingMode===R.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=R.NEAREST_MIPMAP_NEAREST);const t=this._descriptor.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(t,A.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,P(this._descriptor.context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor.context.gl,t=this._descriptor;this._samplingModeDirty&&(v(e,t),this._samplingModeDirty=!1),this._wrapModeDirty&&(y(e,t),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(this._descriptor.context.type===b.WEBGL1)return this._descriptor.internalFormat=this._descriptor.pixelFormat;if(this._descriptor.internalFormat!=null)return this._descriptor.internalFormat===u.DEPTH_STENCIL&&(this._descriptor.internalFormat=u.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case U.FLOAT:switch(this._descriptor.pixelFormat){case u.RGBA:return this._descriptor.internalFormat=s.RGBA32F;case u.RGB:return this._descriptor.internalFormat=s.RGB32F;default:throw new p("Unable to derive format")}case U.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case u.RGBA:return this._descriptor.internalFormat=s.RGBA8;case u.RGB:return this._descriptor.internalFormat=s.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===u.DEPTH_STENCIL?u.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:r,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(e,t,r,i,o,c){const d=this._descriptor.context.gl2;if(d==null)throw new p("Immutable textures are not supported in WebGL1");if(!te(t))throw new p("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const _=r?X(e,i,o,c):1;if(I(e)){if(c==null)throw new p("Missing depth dimension for 3D texture upload");d.texStorage3D(e,_,t,i,o,c)}else d.texStorage2D(e,_,t,i,o);this._wasImmutablyAllocated=!0}_texImage(e,t,r,i,o,c,d){const _=this._descriptor.context.gl,n=I(e),{isImmutable:a,pixelFormat:l,dataType:m}=this._descriptor,h=this._descriptor.context.type===b.WEBGL2,g=h?_:null;if(h||!G(d))if(a){if(d!=null){const T=d;if(n){if(c==null)throw new p("Missing depth dimension for 3D texture upload");g.texSubImage3D(e,t,0,0,0,i,o,c,l,m,T)}else _.texSubImage2D(e,t,0,0,i,o,l,m,T)}}else{const T=d;if(n){if(c==null)throw new p("Missing depth dimension for 3D texture upload");g.texImage3D(e,t,r,i,o,c,0,l,m,T)}else _.texImage2D(e,t,r,i,o,0,l,m,T)}else _.texImage2D(e,0,r,l,m,d)}_compressedTexImage(e,t,r,i,o,c,d){const _=this._descriptor.context.gl;let n=null;const a=I(e),l=this._descriptor.isImmutable;if(a){if(this._descriptor.context.type!==b.WEBGL2)throw new p("3D textures are not supported in WebGL1");n=_}if(l){if(d!=null)if(a){if(c==null)throw new p("Missing depth dimension for 3D texture upload");n.compressedTexSubImage3D(e,t,0,0,0,i,o,c,r,d)}else _.compressedTexSubImage2D(e,t,0,0,i,o,r,d)}else if(a){if(c==null)throw new p("Missing depth dimension for 3D texture upload");n.compressedTexImage3D(e,t,r,i,o,c,0,d)}else _.compressedTexImage2D(e,t,r,i,o,0,d)}_forEachMipmapLevel(e,t=1/0){let{width:r,height:i,depth:o,hasMipmap:c,target:d}=this._descriptor;const _=d===f.TEXTURE_3D;if(r==null||i==null||_&&o==null)throw new p("Missing texture dimensions for mipmap calculation");for(let n=0;e(n,r,i,o),c&&(r!==1||i!==1||_&&o!==1)&&!(n>=t);++n)r=Math.max(1,r>>1),i=Math.max(1,i>>1),_&&(o=Math.max(1,o>>1))}};function P(e,t){(t.width!=null&&t.width<0||t.height!=null&&t.height<0||t.depth!=null&&t.depth<0)&&console.error("Negative dimension parameters are not allowed!");const r=e.type===b.WEBGL2;r||!t.isImmutable&&!I(t.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),!r&&(t.width!=null&&B(t.width)&&t.height!=null&&B(t.height)||(typeof t.wrapMode=="number"?t.wrapMode!==w.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):t.wrapMode.s===w.CLAMP_TO_EDGE&&t.wrapMode.t===w.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),t.hasMipmap&&console.error("Mipmapping requires power-of-two textures!")))}function v(e,t){let r=t.samplingMode,i=t.samplingMode;r===R.LINEAR_MIPMAP_NEAREST||r===R.LINEAR_MIPMAP_LINEAR?(r=R.LINEAR,t.hasMipmap||(i=R.LINEAR)):r!==R.NEAREST_MIPMAP_NEAREST&&r!==R.NEAREST_MIPMAP_LINEAR||(r=R.NEAREST,t.hasMipmap||(i=R.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,r),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,i)}function y(e,t){typeof t.wrapMode=="number"?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}function ee(e,t){const r=e.capabilities.textureFilterAnisotropic;r&&e.gl.texParameterf(t.target,r.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}function te(e){return e in s}function re(e){return e in E}function N(e){return e!=null&&"type"in e&&e.type==="compressed"}function ie(e){return e!=null&&"byteLength"in e}function G(e){return e!=null&&!N(e)&&!ie(e)}function I(e){return e===f.TEXTURE_3D||e===f.TEXTURE_2D_ARRAY}function X(e,t,r,i=1){let o=Math.max(t,r);return e===f.TEXTURE_3D&&(o=Math.max(o,i)),Math.round(Math.log(o)/Math.LN2)+1}A.TEXTURE_UNIT_FOR_UPDATES=0;const se=new Map;export{Z as E,A as T,L as a,j as b,ne as c,ce as d,J as e,le as i,_e as o,D as u};
